<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Guide - Opacus Protocol</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/docs/docs-style.css">
</head>
<body>
    <aside class="docs-sidebar">
        <div class="sidebar-logo">
            <img src="../logo.png" alt="Opacus">
        </div>
        
        <div class="sidebar-section">
            <h4>Getting Started</h4>
            <ul>
                <li><a href="/docs">Overview</a></li>
                <li><a href="/docs/getting-started">Quick Start</a></li>
                <li><a href="/docs/installation">Installation</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>Core Concepts</h4>
            <ul>
                <li><a href="/docs/architecture">Architecture</a></li>
                <li><a href="/docs/identity">Identity System</a></li>
                <li><a href="/docs/encryption">Encryption</a></li>
                <li><a href="/docs/verification">Verification</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>SDKs</h4>
            <ul>
                <li><a href="/docs/typescript">TypeScript SDK</a></li>
                <li><a href="/docs/rust">Rust SDK</a></li>
                <li><a href="/docs/examples">Code Examples</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>Smart Contracts</h4>
            <ul>
                <li><a href="/docs/contracts-overview">Overview</a></li>
                <li><a href="/docs/opacus-core">OpacusCore</a></li>
                <li><a href="/docs/dac-registry">DACRegistry</a></li>
                <li><a href="/docs/agent-registry">AgentRegistry</a></li>
                <li><a href="/docs/deployment">Deployment</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>Advanced</h4>
            <ul>
                <li><a href="/docs/security">Security Model</a></li>
                <li><a href="/docs/performance" class="active">Performance</a></li>
                <li><a href="/docs/troubleshooting">Troubleshooting</a></li>
            </ul>
        </div>
        
        <div class="sidebar-footer">
            <a href="https://github.com/Opacus-xyz/Opacus" target="_blank" rel="noopener">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                <span>GitHub</span>
            </a>
        </div>
    </aside>
    
    <main class="docs-main">
        <div class="docs-header">
            <h1>Performance Guide</h1>
            <p>Optimize Opacus Protocol for high-throughput agent communication.</p>
        </div>
        
        <div class="docs-content">
            <h2>Performance Benchmarks</h2>
            
            <h3>Message Throughput</h3>
            
            <div class="cards-grid">
                <div class="card">
                    <div class="icon">‚ö°</div>
                    <h3>TypeScript SDK</h3>
                    <p><strong>WebSocket:</strong> ~10,000 msg/s<br>
                    <strong>WebTransport:</strong> ~15,000 msg/s<br>
                    <strong>Latency:</strong> 2-5ms avg</p>
                </div>
                
                <div class="card">
                    <div class="icon">üöÄ</div>
                    <h3>Rust SDK</h3>
                    <p><strong>QUIC:</strong> ~50,000 msg/s<br>
                    <strong>Direct:</strong> ~100,000 msg/s<br>
                    <strong>Latency:</strong> <1ms avg</p>
                </div>
                
                <div class="card">
                    <div class="icon">üîê</div>
                    <h3>Encryption</h3>
                    <p><strong>X25519 ECDH:</strong> ~20,000 ops/s<br>
                    <strong>AES-256-GCM:</strong> ~500 MB/s<br>
                    <strong>Ed25519:</strong> ~25,000 signs/s</p>
                </div>
                
                <div class="card">
                    <div class="icon">‚õìÔ∏è</div>
                    <h3>On-Chain</h3>
                    <p><strong>Register:</strong> ~100k gas<br>
                    <strong>Attestation:</strong> ~80k gas<br>
                    <strong>Block Time:</strong> ~3s</p>
                </div>
            </div>
            
            <p><em>Benchmarks run on: M2 MacBook Pro, 16GB RAM, 1Gbps network</em></p>
            
            <h2>Optimization Strategies</h2>
            
            <h3>1. Connection Pooling</h3>
            
            <p>Reuse connections to reduce handshake overhead:</p>
            
            <pre><code>// TypeScript: Connection pool
class ConnectionPool {
  private connections = new Map<string, OpacusClient>();
  
  async getConnection(gatewayUrl: string): Promise<OpacusClient> {
    if (!this.connections.has(gatewayUrl)) {
      const client = new OpacusClient({ gateway: gatewayUrl });
      await client.connect();
      this.connections.set(gatewayUrl, client);
    }
    return this.connections.get(gatewayUrl)!;
  }
}

const pool = new ConnectionPool();
const client = await pool.getConnection('wss://gateway.opacus.ai');

// ‚úÖ Reuses existing connection
// ‚úÖ No handshake overhead
// ‚úÖ 10x faster than reconnecting</code></pre>
            
            <pre><code>// Rust: Connection pool with lazy_static
use lazy_static::lazy_static;
use std::sync::Arc;

lazy_static! {
    static ref CLIENT_POOL: Arc<Mutex<HashMap<String, OpacusClient>>> = 
        Arc::new(Mutex::new(HashMap::new()));
}

async fn get_connection(gateway: &str) -> OpacusClient {
    let mut pool = CLIENT_POOL.lock().await;
    
    pool.entry(gateway.to_string())
        .or_insert_with(|| {
            OpacusClient::new(gateway).connect().await.unwrap()
        })
        .clone()
}</code></pre>
            
            <h3>2. Message Batching</h3>
            
            <p>Send multiple messages in one batch:</p>
            
            <pre><code>// TypeScript: Batch messages
const messages = [
  { to: agent1, content: 'Hello' },
  { to: agent2, content: 'World' },
  { to: agent3, content: 'Batch' }
];

// Bad: Send individually (3 round trips)
for (const msg of messages) {
  await client.sendMessage(msg);
}

// Good: Batch send (1 round trip)
await client.sendBatch(messages);

// ‚úÖ 3x fewer round trips
// ‚úÖ Lower latency
// ‚úÖ Better throughput</code></pre>
            
            <h3>3. Caching</h3>
            
            <p>Cache frequently accessed data:</p>
            
            <pre><code>// TypeScript: Cache agent public keys
class AgentCache {
  private cache = new Map<string, { edKey: string, xKey: string }>();
  private ttl = 5 * 60 * 1000; // 5 minutes
  
  async getKeys(agentId: string) {
    // Check cache first
    if (this.cache.has(agentId)) {
      return this.cache.get(agentId);
    }
    
    // Fetch from contract
    const agent = await agentRegistry.getAgent(agentId);
    const keys = {
      edKey: agent.edPublicKey,
      xKey: agent.xPublicKey
    };
    
    // Cache for future use
    this.cache.set(agentId, keys);
    setTimeout(() => this.cache.delete(agentId), this.ttl);
    
    return keys;
  }
}

// ‚úÖ First call: ~100ms (RPC)
// ‚úÖ Cached calls: <1ms (memory)
// ‚úÖ 100x faster for repeated lookups</code></pre>
            
            <h3>4. Parallel Processing</h3>
            
            <pre><code>// TypeScript: Process messages in parallel
async function processMessages(messages: Message[]) {
  // Bad: Sequential processing
  for (const msg of messages) {
    await handleMessage(msg);
  }
  
  // Good: Parallel processing
  await Promise.all(
    messages.map(msg => handleMessage(msg))
  );
}

// ‚úÖ CPU utilization optimized
// ‚úÖ Latency reduced
// ‚úÖ Throughput increased</code></pre>
            
            <pre><code>// Rust: Parallel processing with Rayon
use rayon::prelude::*;

fn process_messages(messages: Vec<Message>) {
    messages.par_iter()
        .for_each(|msg| {
            handle_message(msg);
        });
}

// ‚úÖ Automatic parallelization
// ‚úÖ Work-stealing scheduler
// ‚úÖ Maximum CPU utilization</code></pre>
            
            <h3>5. Stream Processing</h3>
            
            <pre><code>// Rust: Stream large payloads
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn stream_large_message(
    client: &mut OpacusClient,
    data: &[u8]
) -> Result<()> {
    const CHUNK_SIZE: usize = 64 * 1024; // 64KB chunks
    
    for chunk in data.chunks(CHUNK_SIZE) {
        client.send_chunk(chunk).await?;
    }
    
    client.finish().await?;
    Ok(())
}

// ‚úÖ Memory efficient (constant memory)
// ‚úÖ Handles GB-sized messages
// ‚úÖ Progressive processing</code></pre>
            
            <h2>Gas Optimization</h2>
            
            <h3>Batch Contract Calls</h3>
            
            <pre><code>// TypeScript: Batch on-chain operations
import { Multicall3 } from '@/contracts/Multicall3';

const multicall = new Multicall3(MULTICALL_ADDRESS, provider);

// Bad: 3 separate transactions
await agentRegistry.updateMetadata(agent1, meta1);
await agentRegistry.updateMetadata(agent2, meta2);
await agentRegistry.updateMetadata(agent3, meta3);
// Cost: 3 √ó 50k gas = 150k gas

// Good: 1 multicall transaction
const calls = [
  agentRegistry.interface.encodeFunctionData('updateMetadata', [agent1, meta1]),
  agentRegistry.interface.encodeFunctionData('updateMetadata', [agent2, meta2]),
  agentRegistry.interface.encodeFunctionData('updateMetadata', [agent3, meta3])
];

await multicall.aggregate(calls);
// Cost: ~120k gas (20% savings)</code></pre>
            
            <h3>Optimize Metadata Size</h3>
            
            <pre><code>// Bad: Large JSON metadata
const metadata = JSON.stringify({
  name: 'WeatherBot',
  version: '1.0.0',
  description: 'A comprehensive weather forecasting agent...',
  capabilities: ['weather', 'climate', 'forecasting'],
  author: 'Opacus Team',
  license: 'MIT'
});
// Size: ~200 bytes, Gas: ~100k

// Good: Minimal metadata
const metadata = JSON.stringify({
  name: 'WeatherBot',
  v: '1.0.0',
  cap: ['weather']
});
// Size: ~50 bytes, Gas: ~75k (25% savings)</code></pre>
            
            <h2>Network Optimization</h2>
            
            <h3>Choose Right Protocol</h3>
            
            <ul>
                <li><strong>WebSocket:</strong> Browser clients, moderate throughput</li>
                <li><strong>WebTransport:</strong> Modern browsers, better performance</li>
                <li><strong>QUIC (Rust):</strong> Server-to-server, highest performance</li>
            </ul>
            
            <pre><code>// TypeScript: Protocol selection
const client = new OpacusClient({
  gateway: 'gateway.opacus.ai',
  // Auto-detect best protocol
  protocol: 'auto'  // Tries WebTransport ‚Üí WebSocket
});

// Or explicitly choose
const fastClient = new OpacusClient({
  gateway: 'gateway.opacus.ai',
  protocol: 'webtransport'  // Force WebTransport
});</code></pre>
            
            <h3>Connection Tuning</h3>
            
            <pre><code>// Rust: QUIC connection tuning
let mut config = quinn::ClientConfig::new(Arc::new(crypto));
let mut transport = quinn::TransportConfig::default();

// Increase window sizes
transport.max_concurrent_bidi_streams(1000u32.into());
transport.send_window(10_000_000);  // 10MB
transport.receive_window(10_000_000);

// Reduce latency
transport.max_idle_timeout(Some(Duration::from_secs(30).try_into()?));
transport.keep_alive_interval(Some(Duration::from_secs(5)));

config.transport = Arc::new(transport);

// ‚úÖ Higher throughput
// ‚úÖ Lower latency
// ‚úÖ Better connection stability</code></pre>
            
            <h2>Monitoring & Profiling</h2>
            
            <h3>Measure Performance</h3>
            
            <pre><code>// TypeScript: Performance monitoring
class PerformanceMonitor {
  private metrics = {
    messagesSent: 0,
    messagesReceived: 0,
    avgLatency: 0,
    errors: 0
  };
  
  measureSend(fn: () => Promise<void>) {
    const start = performance.now();
    
    return fn().then(() => {
      const latency = performance.now() - start;
      this.metrics.messagesSent++;
      this.updateLatency(latency);
    }).catch(err => {
      this.metrics.errors++;
      throw err;
    });
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      throughput: this.metrics.messagesSent / (Date.now() / 1000)
    };
  }
}

const monitor = new PerformanceMonitor();

// Use with monitoring
await monitor.measureSend(() => 
  client.sendMessage({ to: agentId, content: 'Hello' })
);

// Check metrics
console.log(monitor.getMetrics());
// { messagesSent: 1234, avgLatency: 3.5ms, throughput: 123 msg/s }</code></pre>
            
            <h3>Profiling</h3>
            
            <pre><code>// Rust: Profiling with criterion
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_encryption(c: &mut Criterion) {
    let plaintext = vec![0u8; 1024];  // 1KB message
    
    c.bench_function("encrypt_message", |b| {
        b.iter(|| {
            let ciphertext = encrypt(black_box(&plaintext));
            black_box(ciphertext);
        });
    });
}

criterion_group!(benches, benchmark_encryption);
criterion_main!(benches);

// Run: cargo bench
// Results:
// encrypt_message         time:   [12.5 ¬µs 12.7 ¬µs 12.9 ¬µs]
//                         thrpt:  [77.5 MiB/s 78.7 MiB/s 80.0 MiB/s]</code></pre>
            
            <h2>Scalability</h2>
            
            <h3>Horizontal Scaling</h3>
            
            <svg viewBox="0 0 800 400" style="max-width: 100%; height: auto; margin: 30px 0;">
                <rect width="800" height="400" fill="#fafafa"/>
                
                <text x="400" y="30" text-anchor="middle" font-size="18" font-weight="600" fill="#333">Load Balancing Architecture</text>
                
                <!-- Load Balancer -->
                <rect x="325" y="60" width="150" height="60" fill="#00D1FF" rx="8"/>
                <text x="400" y="95" text-anchor="middle" font-size="14" font-weight="600" fill="white">Load Balancer</text>
                
                <!-- Gateway Instances -->
                <rect x="100" y="200" width="120" height="60" fill="#00FF88" rx="8"/>
                <text x="160" y="235" text-anchor="middle" font-size="13" fill="white">Gateway 1</text>
                
                <rect x="340" y="200" width="120" height="60" fill="#00FF88" rx="8"/>
                <text x="400" y="235" text-anchor="middle" font-size="13" fill="white">Gateway 2</text>
                
                <rect x="580" y="200" width="120" height="60" fill="#00FF88" rx="8"/>
                <text x="640" y="235" text-anchor="middle" font-size="13" fill="white">Gateway 3</text>
                
                <!-- Connections -->
                <path d="M 380 120 L 160 200" stroke="#333" stroke-width="2"/>
                <path d="M 400 120 L 400 200" stroke="#333" stroke-width="2"/>
                <path d="M 420 120 L 640 200" stroke="#333" stroke-width="2"/>
                
                <!-- Shared State -->
                <rect x="300" y="320" width="200" height="50" fill="#9966FF" rx="8"/>
                <text x="400" y="350" text-anchor="middle" font-size="14" fill="white">Shared State (Redis)</text>
                
                <path d="M 160 260 L 350 320" stroke="#666" stroke-width="1" stroke-dasharray="5,5"/>
                <path d="M 400 260 L 400 320" stroke="#666" stroke-width="1" stroke-dasharray="5,5"/>
                <path d="M 640 260 L 450 320" stroke="#666" stroke-width="1" stroke-dasharray="5,5"/>
            </svg>
            
            <pre><code>// Deploy multiple gateway instances
docker-compose up --scale gateway=3

// Configure load balancer (nginx)
upstream opacus_gateways {
    least_conn;  // Route to least busy
    server gateway1:8080;
    server gateway2:8080;
    server gateway3:8080;
}

server {
    listen 443 ssl;
    location / {
        proxy_pass http://opacus_gateways;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}</code></pre>
            
            <h3>Database Optimization</h3>
            
            <pre><code>// Index frequently queried fields
CREATE INDEX idx_agent_owner ON agents(owner);
CREATE INDEX idx_attestation_subject ON attestations(subject_id);
CREATE INDEX idx_messages_recipient ON messages(recipient_id, timestamp);

// Use read replicas
const primaryDb = new Database(PRIMARY_URL);
const replicaDb = new Database(REPLICA_URL);

// Writes go to primary
await primaryDb.insertMessage(message);

// Reads from replica
const messages = await replicaDb.getMessages(agentId);</code></pre>
            
            <h2>Best Practices Summary</h2>
            
            <div class="cards-grid">
                <div class="card">
                    <div class="icon">üîå</div>
                    <h3>Connections</h3>
                    <ul style="text-align: left; font-size: 14px; margin: 10px 0;">
                        <li>Pool connections</li>
                        <li>Reuse clients</li>
                        <li>Choose right protocol</li>
                    </ul>
                </div>
                
                <div class="card">
                    <div class="icon">üì¶</div>
                    <h3>Messages</h3>
                    <ul style="text-align: left; font-size: 14px; margin: 10px 0;">
                        <li>Batch when possible</li>
                        <li>Stream large data</li>
                        <li>Compress payloads</li>
                    </ul>
                </div>
                
                <div class="card">
                    <div class="icon">üíæ</div>
                    <h3>Caching</h3>
                    <ul style="text-align: left; font-size: 14px; margin: 10px 0;">
                        <li>Cache public keys</li>
                        <li>Cache agent data</li>
                        <li>Use TTL wisely</li>
                    </ul>
                </div>
                
                <div class="card">
                    <div class="icon">‚õΩ</div>
                    <h3>Gas</h3>
                    <ul style="text-align: left; font-size: 14px; margin: 10px 0;">
                        <li>Batch transactions</li>
                        <li>Minimize metadata</li>
                        <li>Use multicall</li>
                    </ul>
                </div>
            </div>
            
            <h2>Performance Checklist</h2>
            
            <ul>
                <li>‚òê Connection pooling implemented</li>
                <li>‚òê Message batching where applicable</li>
                <li>‚òê Caching configured with appropriate TTL</li>
                <li>‚òê Parallel processing for CPU-bound tasks</li>
                <li>‚òê Streaming for large payloads</li>
                <li>‚òê Gas optimization applied</li>
                <li>‚òê Monitoring and profiling in place</li>
                <li>‚òê Load testing completed</li>
                <li>‚òê Horizontal scaling configured</li>
                <li>‚òê Database indexes optimized</li>
            </ul>
            
            <div class="info-box success">
                <h4>üéØ Performance Targets</h4>
                <p>Recommended targets for production:</p>
                <ul>
                    <li><strong>Throughput:</strong> >10,000 msg/s per gateway</li>
                    <li><strong>Latency:</strong> <10ms p99</li>
                    <li><strong>Availability:</strong> >99.9%</li>
                    <li><strong>Gas Cost:</strong> <0.001 0G per operation</li>
                </ul>
            </div>
            
            <h2>Related Documentation</h2>
            
            <ul>
                <li><a href="/docs/architecture">Architecture</a> - System design</li>
                <li><a href="/docs/troubleshooting">Troubleshooting</a> - Common issues</li>
                <li><a href="/docs/deployment">Deployment</a> - Production setup</li>
            </ul>
        </div>
    </main>
</body>
</html>