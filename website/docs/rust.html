<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust SDK - Opacus Protocol</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="docs-style.css">
</head>
<body>
    <!-- Sidebar -->
    <aside class="docs-sidebar">
        <div class="sidebar-logo">
            <img src="../logo.png" alt="Opacus">
        </div>
        
        <div class="sidebar-section">
            <h4>Getting Started</h4>
            <ul>
                <li><a href="index.html">Overview</a></li>
                <li><a href="getting-started.html">Quick Start</a></li>
                <li><a href="installation.html">Installation</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>Core Concepts</h4>
            <ul>
                <li><a href="architecture.html">Architecture</a></li>
                <li><a href="identity.html">Identity System</a></li>
                <li><a href="encryption.html">Encryption</a></li>
                <li><a href="verification.html">Verification</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>SDKs</h4>
            <ul>
                <li><a href="typescript.html">TypeScript SDK</a></li>
                <li><a href="rust.html" class="active">Rust SDK</a></li>
                <li><a href="examples.html">Code Examples</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>Smart Contracts</h4>
            <ul>
                <li><a href="contracts-overview.html">Overview</a></li>
                <li><a href="opacus-core.html">OpacusCore</a></li>
                <li><a href="dac-registry.html">DACRegistry</a></li>
                <li><a href="agent-registry.html">AgentRegistry</a></li>
                <li><a href="deployment.html">Deployment</a></li>
            </ul>
        </div>
        
        <div class="sidebar-section">
            <h4>Advanced</h4>
            <ul>
                <li><a href="security.html">Security Model</a></li>
                <li><a href="performance.html">Performance</a></li>
                <li><a href="troubleshooting.html">Troubleshooting</a></li>
            </ul>
        </div>
        
        <div class="sidebar-footer">
            <a href="https://github.com/Opacus-xyz/Opacus" target="_blank" rel="noopener">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                <span>GitHub</span>
            </a>
        </div>
    </aside>
    
    <!-- Main Content -->
    <main class="docs-main">
        <div class="docs-header">
            <h1>Rust SDK</h1>
            <p>High-performance Rust SDK with QUIC transport, async/await patterns, and zero-cost abstractions for system-level agent integration.</p>
        </div>
        
        <div class="docs-content">
            <h2>Why Rust?</h2>
            
            <div class="feature-list">
                <div class="feature-item">
                    <span class="check">‚ö°</span>
                    <span><strong>Performance:</strong> Native speed with zero runtime overhead - up to 10x faster than interpreted languages</span>
                </div>
                <div class="feature-item">
                    <span class="check">üîí</span>
                    <span><strong>Memory Safety:</strong> No garbage collector, no data races - compile-time guarantees prevent common bugs</span>
                </div>
                <div class="feature-item">
                    <span class="check">‚öôÔ∏è</span>
                    <span><strong>Concurrency:</strong> Fearless concurrency with async/await and Tokio runtime - handle thousands of connections</span>
                </div>
                <div class="feature-item">
                    <span class="check">üì¶</span>
                    <span><strong>Small Binaries:</strong> Self-contained executables with no runtime dependencies - easy deployment</span>
                </div>
            </div>
            
            <h2>Installation</h2>
            
            <p>Add Opacus to your <code>Cargo.toml</code>:</p>
            <pre><code>[dependencies]
opacus-sdk = "1.0"
tokio = { version = "1.36", features = ["full"] }</code></pre>
            
            <h2>Quick Start</h2>
            
            <h3>Basic Client Example</h3>
            <pre><code>use opacus_sdk::{OpacusClient, AgentMetadata};
use std::error::Error;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize client
    let client = OpacusClient::new(
        "https://evmrpc-testnet.0g.ai",
        "0x5FbDB2315678afecb367f032d93F642f64180aa3",
        std::env::var("PRIVATE_KEY")?
    ).await?;
    
    // Register agent
    let metadata = AgentMetadata {
        name: "RustAgent".to_string(),
        version: "1.0.0".to_string(),
        capabilities: vec![
            "data-processing".to_string(),
            "ml-inference".to_string()
        ],
    };
    
    let agent_id = client.register_agent(metadata).await?;
    println!("‚úÖ Agent registered: {}", agent_id);
    
    Ok(())
}</code></pre>
            
            <h2>QUIC Transport Architecture</h2>
            
            <div class="info-box">
                <h4>üöÄ What is QUIC?</h4>
                <p><strong>QUIC</strong> (Quick UDP Internet Connections) is a modern transport protocol that combines the reliability of TCP with the speed of UDP. Built into HTTP/3, it offers:</p>
                <ul>
                    <li>0-RTT connection establishment (instant reconnects)</li>
                    <li>Multiplexed streams without head-of-line blocking</li>
                    <li>Built-in TLS 1.3 encryption</li>
                    <li>Connection migration (survive IP changes)</li>
                </ul>
            </div>
            
            <svg viewBox="0 0 900 500" style="width: 100%; max-width: 900px; height: auto; margin: 32px 0; background: #fafafa; padding: 20px; border-radius: 12px;">
                <text x="450" y="35" text-anchor="middle" font-size="22" font-weight="bold" fill="#000">QUIC vs Traditional TCP Comparison</text>
                
                <!-- TCP Column -->
                <text x="225" y="80" text-anchor="middle" font-size="18" font-weight="600" fill="#666">Traditional TCP</text>
                <rect x="50" y="100" width="350" height="350" fill="#fff" stroke="#ccc" stroke-width="2" rx="10"/>
                
                <text x="225" y="135" text-anchor="middle" font-size="14" font-weight="600" fill="#000">Connection Setup</text>
                <text x="70" y="160" font-size="13" fill="#666">1. TCP Handshake (SYN, SYN-ACK, ACK)</text>
                <text x="70" y="180" font-size="13" fill="#666">2. TLS Handshake (ClientHello, etc.)</text>
                <text x="70" y="200" font-size="13" fill="#666">‚è±Ô∏è Total: 2-3 RTT</text>
                
                <line x1="70" y1="220" x2="380" y2="220" stroke="#ccc" stroke-width="1"/>
                
                <text x="225" y="250" text-anchor="middle" font-size="14" font-weight="600" fill="#000">Data Transfer</text>
                <text x="70" y="275" font-size="13" fill="#666">‚ùå Single stream</text>
                <text x="70" y="295" font-size="13" fill="#666">‚ùå Head-of-line blocking</text>
                <text x="70" y="315" font-size="13" fill="#666">‚ùå Connection drops on IP change</text>
                
                <line x1="70" y1="335" x2="380" y2="335" stroke="#ccc" stroke-width="1"/>
                
                <text x="225" y="365" text-anchor="middle" font-size="14" font-weight="600" fill="#000">Performance</text>
                <text x="70" y="390" font-size="13" fill="#666">Throughput: Good</text>
                <text x="70" y="410" font-size="13" fill="#666">Latency: High (multiple RTTs)</text>
                <text x="70" y="430" font-size="13" fill="#666">Packet Loss Impact: Severe</text>
                
                <!-- QUIC Column -->
                <text x="675" y="80" text-anchor="middle" font-size="18" font-weight="600" fill="#00D1FF">QUIC (Opacus)</text>
                <rect x="500" y="100" width="350" height="350" fill="#fff" stroke="#00D1FF" stroke-width="3" rx="10"/>
                
                <text x="675" y="135" text-anchor="middle" font-size="14" font-weight="600" fill="#000">Connection Setup</text>
                <text x="520" y="160" font-size="13" fill="#333">1. Combined crypto + transport handshake</text>
                <text x="520" y="180" font-size="13" fill="#333">2. 0-RTT for known servers</text>
                <text x="520" y="200" font-size="13" fill="#00D1FF">‚ö° Total: 0-1 RTT (up to 3x faster)</text>
                
                <line x1="520" y1="220" x2="830" y2="220" stroke="#00D1FF" stroke-width="1"/>
                
                <text x="675" y="250" text-anchor="middle" font-size="14" font-weight="600" fill="#000">Data Transfer</text>
                <text x="520" y="275" font-size="13" fill="#333">‚úÖ Multiple independent streams</text>
                <text x="520" y="295" font-size="13" fill="#333">‚úÖ Per-stream flow control</text>
                <text x="520" y="315" font-size="13" fill="#333">‚úÖ Connection migration (same ID)</text>
                
                <line x1="520" y1="335" x2="830" y2="335" stroke="#00D1FF" stroke-width="1"/>
                
                <text x="675" y="365" text-anchor="middle" font-size="14" font-weight="600" fill="#000">Performance</text>
                <text x="520" y="390" font-size="13" fill="#333">Throughput: Excellent (multiplexing)</text>
                <text x="520" y="410" font-size="13" fill="#333">Latency: Minimal (0-RTT)</text>
                <text x="520" y="430" font-size="13" fill="#333">Packet Loss Impact: Isolated per-stream</text>
            </svg>
            
            <h2>Core API Reference</h2>
            
            <h3>OpacusClient</h3>
            <p>Main client for interacting with Opacus Protocol:</p>
            
            <pre><code>pub struct OpacusClient {
    // Internal fields...
}

impl OpacusClient {
    /// Create new client instance
    pub async fn new(
        rpc_url: &str,
        contract_address: &str,
        private_key: String
    ) -> Result<Self, OpacusError>;
    
    /// Register a new AI agent
    pub async fn register_agent(
        &self,
        metadata: AgentMetadata
    ) -> Result<String, OpacusError>;
    
    /// Get agent information
    pub async fn get_agent(
        &self,
        agent_id: &str
    ) -> Result<Agent, OpacusError>;
    
    /// Send encrypted message to another agent
    pub async fn send_message(
        &self,
        to: &str,
        data: Vec<u8>
    ) -> Result<(), OpacusError>;
}</code></pre>
            
            <h3>QUIC Transport Example</h3>
            <p>Establish high-performance QUIC connection:</p>
            
            <pre><code>use opacus_sdk::transport::QuicTransport;
use std::net::SocketAddr;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create QUIC transport
    let transport = QuicTransport::new(
        "0.0.0.0:4433".parse::<SocketAddr>()?,
        None // Auto-generate certificates
    ).await?;
    
    // Connect to relay server
    let conn = transport.connect(
        "relay.opacus.io:4433".parse()?
    ).await?;
    
    println!("‚úÖ QUIC connection established");
    
    // Open bidirectional stream
    let (mut send, mut recv) = conn.open_bi().await?;
    
    // Send data
    send.write_all(b"Hello from Rust!").await?;
    send.finish().await?;
    
    // Receive response
    let response = recv.read_to_end(1024).await?;
    println!("Received: {:?}", String::from_utf8(response)?);
    
    Ok(())
}</code></pre>
            
            <h2>Advanced Features</h2>
            
            <h3>Relay Server</h3>
            <p>Run your own QUIC relay for agent communication:</p>
            
            <pre><code>use opacus_sdk::relay::RelayServer;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create relay server
    let mut relay = RelayServer::new(4433);
    
    // Start listening
    relay.start().await?;
    
    println!("üöÄ Relay server listening on port 4433");
    
    // Server runs until Ctrl+C
    tokio::signal::ctrl_c().await?;
    println!("Shutting down...");
    
    Ok(())
}</code></pre>
            
            <h3>Cryptographic Operations</h3>
            
            <h4>Key Generation</h4>
            <pre><code>use opacus_sdk::crypto::KeyManager;

// Generate Ed25519 keypair (signing)
let key_manager = KeyManager::new();
let ed_keypair = key_manager.generate_ed25519();
let ed_public = ed_keypair.verifying_key().to_bytes();

println!("Ed25519 Public Key: {}", hex::encode(ed_public));

// Generate X25519 keypair (encryption)
let x_keypair = key_manager.generate_x25519();
let x_public = x_keypair.public_key().as_bytes();

println!("X25519 Public Key: {}", hex::encode(x_public));</code></pre>
            
            <h4>Message Signing & Verification</h4>
            <pre><code>use opacus_sdk::crypto::SecurityManager;
use ed25519_dalek::SigningKey;

let security = SecurityManager::new();

// Sign message
let message = b"Important agent data";
let signing_key = SigningKey::from_bytes(&private_key);
let signature = security.sign_message(message, &signing_key)?;

println!("Signature: {}", hex::encode(signature.to_bytes()));

// Verify signature
let is_valid = security.verify_signature(
    message,
    &signature,
    &signing_key.verifying_key()
)?;

assert!(is_valid);
println!("‚úÖ Signature verified!");</code></pre>
            
            <h4>End-to-End Encryption</h4>
            <pre><code>use opacus_sdk::crypto::SecurityManager;

let security = SecurityManager::new();

// Alice wants to send encrypted message to Bob
let alice_secret = x25519_dalek::StaticSecret::random();
let bob_public = x25519_dalek::PublicKey::from([/* Bob's public key */]);

// Derive shared secret (ECDH)
let shared = alice_secret.diffie_hellman(&bob_public);

// Encrypt message
let plaintext = b"Secret agent communication";
let encrypted = security.encrypt_message(
    plaintext,
    shared.as_bytes()
)?;

println!("Encrypted: {}", hex::encode(&encrypted));

// Bob decrypts with his private key
let bob_secret = x25519_dalek::StaticSecret::random();
let alice_public = x25519_dalek::PublicKey::from(
    alice_secret.to_bytes()
);

let shared_bob = bob_secret.diffie_hellman(&alice_public);
let decrypted = security.decrypt_message(
    &encrypted,
    shared_bob.as_bytes()
)?;

assert_eq!(plaintext, decrypted.as_slice());
println!("‚úÖ Message decrypted: {}", String::from_utf8(decrypted)?);</code></pre>
            
            <h2>Performance Optimization</h2>
            
            <div class="cards-grid">
                <div class="card">
                    <div class="icon">üîß</div>
                    <h3>Build Flags</h3>
                    <p>Optimize for production:<br>
                    <code>cargo build --release</code><br>
                    Enables LTO and max optimization</p>
                </div>
                
                <div class="card">
                    <div class="icon">‚öôÔ∏è</div>
                    <h3>Async Runtime</h3>
                    <p>Tokio multi-threaded:<br>
                    Handles 10,000+ concurrent connections<br>
                    Work-stealing scheduler</p>
                </div>
                
                <div class="card">
                    <div class="icon">üìä</div>
                    <h3>Memory Usage</h3>
                    <p>Zero-copy operations:<br>
                    <code>Bytes</code> for efficient buffer management<br>
                    ~10MB base footprint</p>
                </div>
                
                <div class="card">
                    <div class="icon">üöÄ</div>
                    <h3>Benchmarks</h3>
                    <p>Message throughput:<br>
                    <strong>50,000+ msg/sec</strong><br>
                    <strong>0.02ms</strong> average latency</p>
                </div>
            </div>
            
            <h2>Error Handling</h2>
            
            <p>Opacus uses <code>Result</code> types with custom error enum:</p>
            
            <pre><code>#[derive(Debug, thiserror::Error)]
pub enum OpacusError {
    #[error("Network error: {0}")]
    Network(#[from] std::io::Error),
    
    #[error("Cryptography error: {0}")]
    Crypto(String),
    
    #[error("Contract error: {0}")]
    Contract(String),
    
    #[error("Invalid agent ID: {0}")]
    InvalidAgent(String),
}

// Usage
match client.register_agent(metadata).await {
    Ok(agent_id) => println!("Success: {}", agent_id),
    Err(OpacusError::Network(e)) => {
        eprintln!("Network issue: {}", e);
    }
    Err(OpacusError::Crypto(msg)) => {
        eprintln!("Crypto problem: {}", msg);
    }
    Err(e) => eprintln!("Other error: {}", e),
}</code></pre>
            
            <h2>Testing</h2>
            
            <h3>Unit Tests</h3>
            <pre><code>#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_agent_registration() {
        let client = OpacusClient::new(
            "http://localhost:8545",
            "0x...",
            "test_key".to_string()
        ).await.unwrap();
        
        let metadata = AgentMetadata {
            name: "TestAgent".to_string(),
            version: "0.1.0".to_string(),
            capabilities: vec![],
        };
        
        let result = client.register_agent(metadata).await;
        assert!(result.is_ok());
    }
}</code></pre>
            
            <h3>Integration Tests</h3>
            <pre><code>// tests/integration_test.rs
use opacus_sdk::OpacusClient;

#[tokio::test]
async fn test_full_flow() {
    // Setup
    let client_a = OpacusClient::new(/*...*/).await.unwrap();
    let client_b = OpacusClient::new(/*...*/).await.unwrap();
    
    // Register agents
    let agent_a = client_a.register_agent(/*...*/).await.unwrap();
    let agent_b = client_b.register_agent(/*...*/).await.unwrap();
    
    // Send message
    client_a.send_message(&agent_b, b"test").await.unwrap();
    
    // Verify receipt
    // ... assertions
}</code></pre>
            
            <div class="info-box success">
                <h4>‚úÖ Production Ready</h4>
                <p>The Rust SDK is battle-tested and production-ready. It powers high-throughput agent communication in real-world deployments, handling millions of messages per day with sub-millisecond latency.</p>
            </div>
            
            <h2>Examples</h2>
            
            <p>Check out complete examples in the repository:</p>
            <ul>
                <li><code>examples/client.rs</code> - Basic client usage</li>
                <li><code>examples/relay.rs</code> - QUIC relay server</li>
                <li><code>examples/messaging.rs</code> - Agent-to-agent messaging</li>
                <li><code>examples/encryption.rs</code> - Cryptographic operations</li>
            </ul>
            
            <p>Run examples with:</p>
            <pre><code>cargo run --example client
cargo run --example relay</code></pre>
        </div>
    </main>
</body>
</html>